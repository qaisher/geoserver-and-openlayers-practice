{"version":3,"file":"wkb.js","mappings":"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","sources":["webpack:///../src/ol/format/WKB.js","webpack:///./wkb.js"],"sourcesContent":["/**\n * @module ol/format/WKB\n */\nimport Feature from '../Feature.js';\nimport FeatureFormat, {transformGeometryWithOptions} from './Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\n\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport {assign} from '../obj.js';\n\n// WKB spec: https://www.ogc.org/standards/sfa\n// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt\n\n/**\n * @const\n * @enum {number}\n */\nconst WKBGeometryType = {\n  POINT: 1,\n  LINE_STRING: 2,\n  POLYGON: 3,\n  MULTI_POINT: 4,\n  MULTI_LINE_STRING: 5,\n  MULTI_POLYGON: 6,\n  GEOMETRY_COLLECTION: 7,\n\n  /*\n  CIRCULAR_STRING: 8,\n  COMPOUND_CURVE: 9,\n  CURVE_POLYGON: 10,\n\n  MULTI_CURVE: 11,\n  MULTI_SURFACE: 12,\n  CURVE: 13,\n  SURFACE: 14,\n  */\n\n  POLYHEDRAL_SURFACE: 15,\n  TIN: 16,\n  TRIANGLE: 17,\n};\n\nclass WkbReader {\n  /**\n   * @param {DataView} view source to read\n   */\n  constructor(view) {\n    this.view_ = view;\n    this.pos_ = 0;\n\n    this.initialized_ = false;\n    this.isLittleEndian_ = false;\n    this.hasZ_ = false;\n    this.hasM_ = false;\n    /** @type {number|null} */\n    this.srid_ = null;\n\n    this.layout_ = GeometryLayout.XY;\n  }\n\n  /**\n   * @return {number} value\n   */\n  readUint8() {\n    return this.view_.getUint8(this.pos_++);\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readUint32(isLittleEndian) {\n    return this.view_.getUint32(\n      (this.pos_ += 4) - 4,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_\n    );\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readDouble(isLittleEndian) {\n    return this.view_.getFloat64(\n      (this.pos_ += 8) - 8,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_\n    );\n  }\n\n  /**\n   * @return {import('../coordinate.js').Coordinate} coords for Point\n   */\n  readPoint() {\n    /** @type import('../coordinate.js').Coordinate */\n    const coords = [];\n\n    coords.push(this.readDouble());\n    coords.push(this.readDouble());\n    if (this.hasZ_) {\n      coords.push(this.readDouble());\n    }\n    if (this.hasM_) {\n      coords.push(this.readDouble());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing\n   */\n  readLineString() {\n    const numPoints = this.readUint32();\n\n    /** @type Array<import('../coordinate.js').Coordinate> */\n    const coords = [];\n    for (let i = 0; i < numPoints; i++) {\n      coords.push(this.readPoint());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like\n   */\n  readPolygon() {\n    const numRings = this.readUint32();\n\n    /** @type Array<Array<import('../coordinate.js').Coordinate>> */\n    const rings = [];\n    for (let i = 0; i < numRings; i++) {\n      rings.push(this.readLineString()); // as a LinearRing\n    }\n\n    return rings;\n  }\n\n  /**\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {number} WKB Type ID\n   */\n  readWkbHeader(expectedTypeId) {\n    const byteOrder = this.readUint8();\n    const isLittleEndian = byteOrder > 0;\n\n    const wkbType = this.readUint32(isLittleEndian);\n    const wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);\n    const hasZ =\n      Boolean(wkbType & 0x80000000) ||\n      wkbTypeThousandth === 1 ||\n      wkbTypeThousandth === 3;\n    const hasM =\n      Boolean(wkbType & 0x40000000) ||\n      wkbTypeThousandth === 2 ||\n      wkbTypeThousandth === 3;\n    const hasSRID = Boolean(wkbType & 0x20000000);\n    const typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID\n    const layout = ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('');\n\n    const srid = hasSRID ? this.readUint32(isLittleEndian) : null;\n\n    if (expectedTypeId !== undefined && expectedTypeId !== typeId) {\n      throw new Error('Unexpected WKB geometry type ' + typeId);\n    }\n\n    if (this.initialized_) {\n      // sanity checks\n      if (this.isLittleEndian_ !== isLittleEndian) {\n        throw new Error('Inconsistent endian');\n      }\n      if (this.layout_ !== layout) {\n        throw new Error('Inconsistent geometry layout');\n      }\n      if (srid && this.srid_ !== srid) {\n        throw new Error('Inconsistent coordinate system (SRID)');\n      }\n    } else {\n      this.isLittleEndian_ = isLittleEndian;\n      this.hasZ_ = hasZ;\n      this.hasM_ = hasM;\n      this.layout_ = layout;\n      this.srid_ = srid;\n      this.initialized_ = true;\n    }\n\n    return typeId;\n  }\n\n  /**\n   * @param {number} typeId WKB Type ID\n   * @return {any} values read\n   */\n  readWkbPayload(typeId) {\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return this.readPoint();\n\n      case WKBGeometryType.LINE_STRING:\n        return this.readLineString();\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return this.readPolygon();\n\n      case WKBGeometryType.MULTI_POINT:\n        return this.readMultiPoint();\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return this.readMultiLineString();\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return this.readMultiPolygon();\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return this.readGeometryCollection();\n\n      default:\n        throw new Error(\n          'Unsupported WKB geometry type ' + typeId + ' is found'\n        );\n    }\n  }\n\n  /**\n   * @param {number} expectedTypeId Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbBlock(expectedTypeId) {\n    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));\n  }\n\n  /**\n   * @param {Function} reader reader function for each item\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbCollection(reader, expectedTypeId) {\n    const num = this.readUint32();\n\n    const items = [];\n    for (let i = 0; i < num; i++) {\n      const result = reader.call(this, expectedTypeId);\n      if (result) {\n        items.push(result);\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint\n   */\n  readMultiPoint() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like\n   */\n  readMultiLineString() {\n    return this.readWkbCollection(\n      this.readWkbBlock,\n      WKBGeometryType.LINE_STRING\n    );\n  }\n\n  /**\n   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like\n   */\n  readMultiPolygon() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);\n  }\n\n  /**\n   * @return {Array<import('../geom/Geometry.js').default>} array of geometries\n   */\n  readGeometryCollection() {\n    return this.readWkbCollection(this.readGeometry);\n  }\n\n  /**\n   * @return {import('../geom/Geometry.js').default} geometry\n   */\n  readGeometry() {\n    const typeId = this.readWkbHeader();\n    const result = this.readWkbPayload(typeId);\n\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return new Point(\n          /** @type {import('../coordinate.js').Coordinate} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.LINE_STRING:\n        return new LineString(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return new Polygon(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_POINT:\n        return new MultiPoint(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return new MultiLineString(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return new MultiPolygon(\n          /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return new GeometryCollection(\n          /** @type {Array<import('../geom/Geometry.js').default>} */ (result)\n        );\n\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * @return {number|null} SRID in the EWKB. `null` if not defined.\n   */\n  getSrid() {\n    return this.srid_;\n  }\n}\n\nclass WkbWriter {\n  /**\n   * @type {Object}\n   * @property {string} [layout] geometryLayout\n   * @property {boolean} [littleEndian=true] littleEndian\n   * @property {boolean} [ewkb=true] Whether writes in EWKB format\n   * @property {Object} [nodata] NoData value for each axes\n   * @param {Object} opts options\n   */\n  constructor(opts) {\n    opts = opts || {};\n\n    /** @type {string} */\n    this.layout_ = opts.layout;\n    this.isLittleEndian_ = opts.littleEndian !== false;\n\n    this.isEWKB_ = opts.ewkb !== false;\n\n    /** @type {Array<Array<number>>} */\n    this.writeQueue_ = [];\n\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} Z NoData value for Z\n     * @property {number} M NoData value for M\n     */\n    this.nodata_ = assign({X: 0, Y: 0, Z: 0, M: 0}, opts.nodata);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint8(value) {\n    this.writeQueue_.push([1, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint32(value) {\n    this.writeQueue_.push([4, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeDouble(value) {\n    this.writeQueue_.push([8, value]);\n  }\n\n  /**\n   * @param {import('../coordinate.js').Coordinate} coords coords\n   * @param {import(\"../geom/GeometryLayout\").default} layout layout\n   */\n  writePoint(coords, layout) {\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} [Z] NoData value for Z\n     * @property {number} [M] NoData value for M\n     */\n    const coordsObj = assign.apply(\n      null,\n      layout.split('').map((axis, idx) => ({[axis]: coords[idx]}))\n    );\n\n    for (const axis of this.layout_) {\n      this.writeDouble(\n        axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]\n      );\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/GeometryLayout\").default} layout layout\n   */\n  writeLineString(coords, layout) {\n    this.writeUint32(coords.length); // numPoints\n    for (let i = 0; i < coords.length; i++) {\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings\n   * @param {import(\"../geom/GeometryLayout\").default} layout layout\n   */\n  writePolygon(rings, layout) {\n    this.writeUint32(rings.length); // numRings\n    for (let i = 0; i < rings.length; i++) {\n      this.writeLineString(rings[i], layout); // as a LinearRing\n    }\n  }\n\n  /**\n   * @param {number} wkbType WKB Type ID\n   * @param {number} [srid] SRID\n   */\n  writeWkbHeader(wkbType, srid) {\n    wkbType %= 1000; // Assume 1000 is an upper limit for type ID\n    if (this.layout_.indexOf('Z') >= 0) {\n      wkbType += this.isEWKB_ ? 0x80000000 : 1000;\n    }\n    if (this.layout_.indexOf('M') >= 0) {\n      wkbType += this.isEWKB_ ? 0x40000000 : 2000;\n    }\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      wkbType |= 0x20000000;\n    }\n\n    this.writeUint8(this.isLittleEndian_ ? 1 : 0);\n    this.writeUint32(wkbType);\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      this.writeUint32(srid);\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {string} layout layout\n   */\n  writeMultiPoint(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(1);\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords\n   * @param {string} layout layout\n   */\n  writeMultiLineString(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(2);\n      this.writeLineString(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords\n   * @param {string} layout layout\n   */\n  writeMultiPolygon(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(3);\n      this.writePolygon(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries\n   */\n  writeGeometryCollection(geometries) {\n    this.writeUint32(geometries.length); // numItems\n\n    for (let i = 0; i < geometries.length; i++) {\n      this.writeGeometry(geometries[i]);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {import(\"../geom/GeometryLayout.js\").default} [layout] layout\n   * @return {import(\"../geom/GeometryLayout.js\").default} minumum layout made by common axes\n   */\n  findMinimumLayout(geom, layout = GeometryLayout.XYZM) {\n    /**\n     * @param {import(\"../geom/GeometryLayout.js\").default} a A\n     * @param {import(\"../geom/GeometryLayout.js\").default} b B\n     * @return {import(\"../geom/GeometryLayout.js\").default} minumum layout made by common axes\n     */\n    const GeometryLayout_min = (a, b) => {\n      if (a === b) {\n        return a;\n      }\n\n      if (a === GeometryLayout.XYZM) {\n        // anything `b` is minimum\n        return b;\n      }\n      if (b === GeometryLayout.XYZM) {\n        // anything `a` is minimum\n        return a;\n      }\n\n      // otherwise, incompatible\n      return GeometryLayout.XY;\n    };\n\n    if (geom instanceof SimpleGeometry) {\n      return GeometryLayout_min(geom.getLayout(), layout);\n    }\n\n    if (geom instanceof GeometryCollection) {\n      const geoms = geom.getGeometriesArray();\n      for (let i = 0; i < geoms.length && layout !== GeometryLayout.XY; i++) {\n        layout = this.findMinimumLayout(geoms[i], layout);\n      }\n    }\n\n    return layout;\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {number} [srid] SRID\n   */\n  writeGeometry(geom, srid) {\n    /**\n     * @type {Object<import(\"../geom/Geometry.js\").Type, WKBGeometryType>}\n     */\n    const wkblut = {\n      Point: WKBGeometryType.POINT,\n      LineString: WKBGeometryType.LINE_STRING,\n      Polygon: WKBGeometryType.POLYGON,\n      MultiPoint: WKBGeometryType.MULTI_POINT,\n      MultiLineString: WKBGeometryType.MULTI_LINE_STRING,\n      MultiPolygon: WKBGeometryType.MULTI_POLYGON,\n      GeometryCollection: WKBGeometryType.GEOMETRY_COLLECTION,\n    };\n    const geomType = geom.getType();\n    const typeId = wkblut[geomType];\n\n    if (!typeId) {\n      throw new Error('GeometryType ' + geomType + ' is not supported');\n    }\n\n    // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.\n    if (!this.layout_) {\n      this.layout_ = this.findMinimumLayout(geom);\n    }\n\n    this.writeWkbHeader(typeId, srid);\n\n    if (geom instanceof SimpleGeometry) {\n      const writerLUT = {\n        Point: this.writePoint,\n        LineString: this.writeLineString,\n        Polygon: this.writePolygon,\n        MultiPoint: this.writeMultiPoint,\n        MultiLineString: this.writeMultiLineString,\n        MultiPolygon: this.writeMultiPolygon,\n      };\n      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());\n    } else if (geom instanceof GeometryCollection) {\n      this.writeGeometryCollection(geom.getGeometriesArray());\n    }\n  }\n\n  getBuffer() {\n    const byteLength = this.writeQueue_.reduce((acc, item) => acc + item[0], 0);\n    const buffer = new ArrayBuffer(byteLength);\n    const view = new DataView(buffer);\n\n    let pos = 0;\n    this.writeQueue_.forEach((item) => {\n      switch (item[0]) {\n        case 1:\n          view.setUint8(pos, item[1]);\n          break;\n        case 4:\n          view.setUint32(pos, item[1], this.isLittleEndian_);\n          break;\n        case 8:\n          view.setFloat64(pos, item[1], this.isLittleEndian_);\n          break;\n        default:\n          break;\n      }\n\n      pos += item[0];\n    });\n\n    return buffer;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.\n * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.\n * @property {boolean} [littleEndian=true] Use littleEndian for output.\n * @property {boolean} [ewkb=true] Use EWKB format for output.\n * @property {import(\"../geom/GeometryLayout\").default} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)\n * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.\n * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.\n * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.\n */\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.\n * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.\n *\n * @api\n */\nclass WKB extends FeatureFormat {\n  /**\n   * @param {Options} [opt_options] Optional configuration object.\n   */\n  constructor(opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    this.splitCollection = Boolean(options.splitCollection);\n\n    this.viewCache_ = null;\n\n    this.hex_ = options.hex !== false;\n    this.littleEndian_ = options.littleEndian !== false;\n    this.ewkb_ = options.ewkb !== false;\n\n    this.layout_ = options.geometryLayout; // null for auto detect\n    this.nodataZ_ = options.nodataZ || 0;\n    this.nodataM_ = options.nodataM || 0;\n\n    this.srid_ = options.srid;\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return this.hex_ ? 'text' : 'arraybuffer';\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, opt_options) {\n    return new Feature({\n      geometry: this.readGeometry(source, opt_options),\n    });\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, opt_options) {\n    let geometries = [];\n    const geometry = this.readGeometry(source, opt_options);\n    if (this.splitCollection && geometry instanceof GeometryCollection) {\n      geometries = geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    return geometries.map((geometry) => new Feature({geometry}));\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n  readGeometry(source, opt_options) {\n    const view = getDataView(source);\n    if (!view) {\n      return null;\n    }\n\n    const reader = new WkbReader(view);\n    const geometry = reader.readGeometry();\n\n    this.viewCache_ = view; // cache for internal subsequent call of readProjection()\n    const options = this.getReadOptions(source, opt_options);\n    this.viewCache_ = null; // release\n\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   * @api\n   */\n  readProjection(source) {\n    const view = this.viewCache_ || getDataView(source);\n    if (!view) {\n      return undefined;\n    }\n\n    const reader = new WkbReader(view);\n    reader.readWkbHeader();\n\n    return (\n      (reader.getSrid() && getProjection('EPSG:' + reader.getSrid())) ||\n      undefined\n    );\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeature(feature, opt_options) {\n    return this.writeGeometry(feature.getGeometry(), opt_options);\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeatures(features, opt_options) {\n    return this.writeGeometry(\n      new GeometryCollection(features.map((f) => f.getGeometry())),\n      opt_options\n    );\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeGeometry(geometry, opt_options) {\n    const options = this.adaptOptions(opt_options);\n\n    const writer = new WkbWriter({\n      layout: this.layout_,\n      littleEndian: this.littleEndian_,\n      ewkb: this.ewkb_,\n\n      nodata: {\n        Z: this.nodataZ_,\n        M: this.nodataM_,\n      },\n    });\n\n    // extract SRID from `dataProjection`\n    let srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;\n    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {\n      const dataProjection =\n        options.dataProjection && getProjection(options.dataProjection);\n      if (dataProjection) {\n        const code = dataProjection.getCode();\n        if (code.indexOf('EPSG:') === 0) {\n          srid = Number(code.substring(5));\n        }\n      }\n    }\n\n    writer.writeGeometry(\n      transformGeometryWithOptions(geometry, true, options),\n      srid\n    );\n    const buffer = writer.getBuffer();\n\n    return this.hex_ ? encodeHexString(buffer) : buffer;\n  }\n}\n\n/**\n * @param {ArrayBuffer} buffer source buffer\n * @return {string} encoded hex string\n */\nfunction encodeHexString(buffer) {\n  const view = new Uint8Array(buffer);\n  return Array.from(view.values())\n    .map((x) => (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase())\n    .join('');\n}\n\n/**\n * @param {string} text source text\n * @return {DataView} decoded binary buffer\n */\nfunction decodeHexString(text) {\n  const buffer = new Uint8Array(text.length / 2);\n  for (let i = 0; i < text.length / 2; i++) {\n    buffer[i] = parseInt(text.substr(i * 2, 2), 16);\n  }\n  return new DataView(buffer.buffer);\n}\n\n/**\n * @param {string | ArrayBuffer | ArrayBufferView} source source\n * @return {DataView} data view\n */\nfunction getDataView(source) {\n  if (typeof source === 'string') {\n    return decodeHexString(source);\n  } else if (ArrayBuffer.isView(source)) {\n    if (source instanceof DataView) {\n      return source;\n    }\n    return new DataView(source.buffer, source.byteOffset, source.byteLength);\n  } else if (source instanceof ArrayBuffer) {\n    return new DataView(source);\n  } else {\n    return null;\n  }\n}\n\nexport default WKB;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport WKB from '../src/ol/format/WKB.js';\nimport {OSM, Vector as VectorSource} from '../src/ol/source.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\n\nconst raster = new TileLayer({\n  source: new OSM(),\n});\n\nconst wkb =\n  '0103000000010000000500000054E3A59BC4602540643BDF4F8D1739C05C8FC2F5284C4140EC51B81E852B34C0D578E926316843406F1283C0CAD141C01B2FDD2406012B40A4703D0AD79343C054E3A59BC4602540643BDF4F8D1739C0';\n\nconst format = new WKB();\n\nconst feature = format.readFeature(wkb, {\n  dataProjection: 'EPSG:4326',\n  featureProjection: 'EPSG:3857',\n});\n\nconst vector = new VectorLayer({\n  source: new VectorSource({\n    features: [feature],\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, vector],\n  target: 'map',\n  view: new View({\n    center: [2952104.0199, -3277504.823],\n    zoom: 4,\n  }),\n});\n"],"names":["WKBGeometryType","WkbReader","constructor","view","this","view_","pos_","initialized_","isLittleEndian_","hasZ_","hasM_","srid_","layout_","GeometryLayout","readUint8","getUint8","readUint32","isLittleEndian","getUint32","undefined","readDouble","getFloat64","readPoint","coords","push","readLineString","numPoints","i","readPolygon","numRings","rings","readWkbHeader","expectedTypeId","wkbType","wkbTypeThousandth","Math","floor","hasZ","Boolean","hasM","hasSRID","typeId","layout","join","srid","Error","readWkbPayload","readMultiPoint","readMultiLineString","readMultiPolygon","readGeometryCollection","readWkbBlock","readWkbCollection","reader","num","items","result","call","readGeometry","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection","getSrid","WkbWriter","opts","littleEndian","isEWKB_","ewkb","writeQueue_","nodata_","assign","X","Y","Z","M","nodata","writeUint8","value","writeUint32","writeDouble","writePoint","coordsObj","split","map","axis","idx","writeLineString","length","writePolygon","writeWkbHeader","indexOf","Number","isInteger","writeMultiPoint","writeMultiLineString","writeMultiPolygon","writeGeometryCollection","geometries","writeGeometry","findMinimumLayout","geom","SimpleGeometry","a","getLayout","b","geoms","getGeometriesArray","wkblut","geomType","getType","getCoordinates","getBuffer","byteLength","reduce","acc","item","buffer","ArrayBuffer","DataView","pos","forEach","setUint8","setUint32","setFloat64","WKB","FeatureFormat","opt_options","super","options","splitCollection","viewCache_","hex_","hex","littleEndian_","ewkb_","geometryLayout","nodataZ_","nodataZ","nodataM_","nodataM","readFeature","source","Feature","geometry","readFeatures","getDataView","getReadOptions","transformGeometryWithOptions","readProjection","getProjection","writeFeature","feature","getGeometry","writeFeatures","features","f","adaptOptions","writer","dataProjection","code","getCode","substring","Uint8Array","Array","from","values","x","toString","toUpperCase","encodeHexString","text","parseInt","substr","decodeHexString","isView","byteOffset","raster","TileLayer","OSM","featureProjection","vector","VectorLayer","VectorSource","Map","layers","target","View","center","zoom"],"sourceRoot":""}